"""S3-compatible object storage client.

This module provides the server-side S3 client for uploading output files
generated by sandbox code execution.
"""

import uuid
from pathlib import Path
from typing import Any

import boto3
import structlog
from botocore.config import Config as BotoConfig

from xatu_mcp.config import StorageConfig

logger = structlog.get_logger()


class S3Storage:
    """S3-compatible object storage client.

    Supports MinIO for local development and R2/S3 for production.
    """

    def __init__(self, config: StorageConfig) -> None:
        """Initialize S3 storage client.

        Args:
            config: Storage configuration.
        """
        self.config = config
        self._client: Any | None = None

    @property
    def client(self) -> Any:
        """Get or create S3 client."""
        if self._client is None:
            self._client = boto3.client(
                "s3",
                endpoint_url=self.config.endpoint,
                aws_access_key_id=self.config.access_key,
                aws_secret_access_key=self.config.secret_key,
                region_name=self.config.region,
                config=BotoConfig(signature_version="s3v4"),
            )
        return self._client

    def upload_file(
        self,
        local_path: Path,
        key: str | None = None,
        content_type: str | None = None,
    ) -> str:
        """Upload a file to S3.

        Args:
            local_path: Path to the local file.
            key: S3 object key. If None, generates one from the filename.
            content_type: MIME type. If None, auto-detected from extension.

        Returns:
            Public URL for the uploaded file.

        Raises:
            FileNotFoundError: If the local file doesn't exist.
        """
        if not local_path.exists():
            raise FileNotFoundError(f"File not found: {local_path}")

        if key is None:
            # Generate unique key
            unique_id = str(uuid.uuid4())[:8]
            key = f"{unique_id}/{local_path.name}"

        if content_type is None:
            content_type = self._get_content_type(local_path.suffix)

        logger.debug(
            "Uploading file to S3",
            local_path=str(local_path),
            key=key,
            content_type=content_type,
        )

        with open(local_path, "rb") as f:
            self.client.upload_fileobj(
                f,
                self.config.bucket,
                key,
                ExtraArgs={"ContentType": content_type},
            )

        url = self.get_public_url(key)

        logger.info("File uploaded to S3", key=key, url=url)

        return url

    def upload_bytes(
        self,
        data: bytes,
        key: str,
        content_type: str = "application/octet-stream",
    ) -> str:
        """Upload bytes to S3.

        Args:
            data: Bytes to upload.
            key: S3 object key.
            content_type: MIME type.

        Returns:
            Public URL for the uploaded file.
        """
        import io

        logger.debug(
            "Uploading bytes to S3",
            key=key,
            size=len(data),
            content_type=content_type,
        )

        self.client.upload_fileobj(
            io.BytesIO(data),
            self.config.bucket,
            key,
            ExtraArgs={"ContentType": content_type},
        )

        url = self.get_public_url(key)

        logger.info("Bytes uploaded to S3", key=key, url=url)

        return url

    def get_public_url(self, key: str) -> str:
        """Get the public URL for an object.

        Args:
            key: S3 object key.

        Returns:
            Public URL.
        """
        if self.config.public_url_prefix:
            return f"{self.config.public_url_prefix.rstrip('/')}/{key}"
        else:
            return f"{self.config.endpoint.rstrip('/')}/{self.config.bucket}/{key}"

    def get_presigned_url(self, key: str, expires_in: int = 3600) -> str:
        """Generate a presigned URL for an object.

        Args:
            key: S3 object key.
            expires_in: URL expiration time in seconds.

        Returns:
            Presigned URL.
        """
        return self.client.generate_presigned_url(
            "get_object",
            Params={"Bucket": self.config.bucket, "Key": key},
            ExpiresIn=expires_in,
        )

    def delete(self, key: str) -> None:
        """Delete an object from S3.

        Args:
            key: S3 object key.
        """
        logger.debug("Deleting from S3", key=key)
        self.client.delete_object(Bucket=self.config.bucket, Key=key)

    def list_objects(self, prefix: str = "") -> list[dict[str, Any]]:
        """List objects in the bucket.

        Args:
            prefix: Optional prefix to filter objects.

        Returns:
            List of object info dictionaries.
        """
        response = self.client.list_objects_v2(
            Bucket=self.config.bucket,
            Prefix=prefix,
        )

        objects = []
        for obj in response.get("Contents", []):
            objects.append({
                "key": obj["Key"],
                "size": obj["Size"],
                "last_modified": obj["LastModified"].isoformat(),
                "url": self.get_public_url(obj["Key"]),
            })

        return objects

    def ensure_bucket_exists(self) -> None:
        """Ensure the bucket exists, creating it if necessary."""
        try:
            self.client.head_bucket(Bucket=self.config.bucket)
            logger.debug("Bucket exists", bucket=self.config.bucket)
        except self.client.exceptions.ClientError as e:
            if e.response["Error"]["Code"] == "404":
                logger.info("Creating bucket", bucket=self.config.bucket)
                self.client.create_bucket(Bucket=self.config.bucket)
            else:
                raise

    @staticmethod
    def _get_content_type(suffix: str) -> str:
        """Get MIME type for a file suffix.

        Args:
            suffix: File suffix including the dot.

        Returns:
            MIME type string.
        """
        content_types = {
            ".png": "image/png",
            ".jpg": "image/jpeg",
            ".jpeg": "image/jpeg",
            ".gif": "image/gif",
            ".svg": "image/svg+xml",
            ".pdf": "application/pdf",
            ".csv": "text/csv",
            ".json": "application/json",
            ".html": "text/html",
            ".txt": "text/plain",
            ".parquet": "application/octet-stream",
        }

        return content_types.get(suffix.lower(), "application/octet-stream")
