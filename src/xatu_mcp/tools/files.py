"""File management tools for output files."""

from typing import Any

from mcp.server import Server
from mcp.types import TextContent, Tool
import structlog

from xatu_mcp.config import Config

logger = structlog.get_logger()

# Global storage for output files per session
# In production, this would be backed by actual S3 storage
_output_files: dict[str, dict[str, Any]] = {}


def register_file_tools(server: Server, config: Config) -> None:
    """Register file management tools with the MCP server.

    Args:
        server: The MCP server instance.
        config: Server configuration.
    """

    # Get the existing list_tools handler and extend it
    existing_list_tools = getattr(server, "_list_tools_handler", None)

    @server.list_tools()
    async def list_tools() -> list[Tool]:
        tools = []

        # Add existing tools if handler exists
        if existing_list_tools:
            existing = await existing_list_tools()
            tools.extend(existing)

        # Add file tools
        tools.extend([
            Tool(
                name="get_output_file",
                description="""Get a URL for an output file generated by execute_python.

After code execution, output files are stored temporarily and can be
retrieved via this tool. The server uploads files to S3-compatible
storage and returns a public URL.

Files are available for a limited time after execution.""",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "filename": {
                            "type": "string",
                            "description": "Name of the file in /output/ directory",
                        },
                        "execution_id": {
                            "type": "string",
                            "description": "Execution ID (optional, uses most recent if not specified)",
                        },
                    },
                    "required": ["filename"],
                },
            ),
            Tool(
                name="list_output_files",
                description="""List all output files from the most recent execution.

Returns the filenames of all files that were written to /output/
during code execution.""",
                inputSchema={
                    "type": "object",
                    "properties": {
                        "execution_id": {
                            "type": "string",
                            "description": "Execution ID (optional, uses most recent if not specified)",
                        },
                    },
                },
            ),
        ])

        return tools

    existing_call_tool = getattr(server, "_call_tool_handler", None)

    @server.call_tool()
    async def call_tool(name: str, arguments: dict[str, Any]) -> list[TextContent]:
        if name == "get_output_file":
            return await _handle_get_output_file(arguments, config)
        elif name == "list_output_files":
            return await _handle_list_output_files(arguments, config)
        elif existing_call_tool:
            return await existing_call_tool(name, arguments)
        else:
            raise ValueError(f"Unknown tool: {name}")


async def _handle_get_output_file(
    arguments: dict[str, Any],
    config: Config,
) -> list[TextContent]:
    """Handle the get_output_file tool call.

    Args:
        arguments: Tool arguments.
        config: Server configuration.

    Returns:
        Text content with file URL or error message.
    """
    filename = arguments.get("filename")
    if not filename:
        raise ValueError("filename is required")

    execution_id = arguments.get("execution_id")

    logger.info(
        "Getting output file",
        filename=filename,
        execution_id=execution_id,
    )

    # In a real implementation, this would:
    # 1. Look up the file in the output directory for the execution
    # 2. Upload it to S3 if not already uploaded
    # 3. Return a presigned URL

    # For now, return a placeholder
    if config.storage:
        base_url = config.storage.public_url_prefix or f"{config.storage.endpoint}/{config.storage.bucket}"
        file_key = f"{execution_id or 'latest'}/{filename}"
        url = f"{base_url}/{file_key}"

        return [
            TextContent(
                type="text",
                text=f"URL: {url}\n\nNote: File upload to S3 not yet implemented. "
                "In production, this would return a presigned URL to the uploaded file.",
            )
        ]
    else:
        return [
            TextContent(
                type="text",
                text="Error: Storage not configured. Add storage configuration to enable file retrieval.",
            )
        ]


async def _handle_list_output_files(
    arguments: dict[str, Any],
    config: Config,
) -> list[TextContent]:
    """Handle the list_output_files tool call.

    Args:
        arguments: Tool arguments.
        config: Server configuration.

    Returns:
        Text content with list of files or error message.
    """
    execution_id = arguments.get("execution_id")

    logger.info(
        "Listing output files",
        execution_id=execution_id,
    )

    # In a real implementation, this would list files from the execution's output directory
    # For now, return a placeholder

    return [
        TextContent(
            type="text",
            text="No output files found.\n\nNote: Output file tracking not yet fully implemented. "
            "Use execute_python to generate output files.",
        )
    ]


# Export for use in __init__.py
async def execute_python(*args: Any, **kwargs: Any) -> Any:
    """Placeholder for execute_python - actual implementation is registered via register_execute_python."""
    raise NotImplementedError("Use register_execute_python to set up the tool")


async def get_output_file(*args: Any, **kwargs: Any) -> Any:
    """Placeholder for get_output_file - actual implementation is registered via register_file_tools."""
    raise NotImplementedError("Use register_file_tools to set up the tool")


async def list_output_files(*args: Any, **kwargs: Any) -> Any:
    """Placeholder for list_output_files - actual implementation is registered via register_file_tools."""
    raise NotImplementedError("Use register_file_tools to set up the tool")
